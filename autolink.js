// Generated by LiveScript 1.5.0
(function(){
  var fs, os, lang, pre2, audioMap, k, v, LTMRegexes, lenToRegex, lens, PUA2UNI, grok, entries, i, todo, i$, len$, entry, title, heteronyms, pre, code, idx, englishIndex, j$, len1$, b, audioTitle, audioId, chunk, x, replace$ = ''.replace;
  fs = require('fs');
  os = require('os');
  lang = process.argv[2];
  if (lang !== 'p' && lang !== 'm' && lang !== 's') {
    console.log("Please invoke this program with a single-letter argument, one of <[ p m s ]>.");
    process.exit();
  }
  pre2 = fs.readFileSync(lang + "/lenToRegex.json");
  if (lang === 'a') {
    audioMap = JSON.parse(fs.readFileSync('dict-concised.audio.json', 'utf8'));
  }
  for (k in audioMap) {
    v = audioMap[k];
    k = replace$.call(k.replace(/\.（.*?）/, '.'), /，/g, '').replace(/（.*）.*/, '');
    audioMap[k] = v;
    k = replace$.call(k, /\..*/, '');
    audioMap[k] = v;
  }
  LTMRegexes = [];
  eval("var pre2 = " + pre2 + ";");
  eval("var lenToRegex, lens, LTMRegexes = [];");
  eval(init);
  eval('init()');
  eval(proc);
  eval(procNoSeg);
  function proc(struct, title, idx){
    var chunk, i$, ref$, len$, re, esc, codepointsOf, titleCodes, len;
    chunk = JSON.stringify(struct);
    for (i$ = 0, len$ = (ref$ = LTMRegexes).length; i$ < len$; ++i$) {
      re = ref$[i$];
      chunk = chunk.replace(re, fn$);
    }
    esc = escape(title);
    codepointsOf = function(it){
      return it.length - it.split(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g).length + 1;
    };
    titleCodes = codepointsOf(title);
    for (i$ = 0, len$ = (ref$ = lens).length; i$ < len$; ++i$) {
      len = ref$[i$];
      if (len < titleCodes) {
        title = title.replace(lenToRegex[len], fn1$);
      }
    }
    return (idx + " " + esc + " ") + unescape(chunk).replace(/"t":""/, "\"t\":\"" + unescape(title) + "\"");
    function fn$(it){
      return escape("`" + it + "~");
    }
    function fn1$(it){
      return escape("`" + it + "~");
    }
  }
  function procNoSeg(chunk, title, idx){
    var esc;
    esc = escape(title);
    return (idx + " " + esc + " ") + unescape(chunk).replace(/"t":""/, "\"t\":\"" + unescape(title) + "\"");
  }
  lenToRegex = {};
  lens = [];
  function init(){
    var len, i$, len$, results$ = [];
    lenToRegex = pre2.lenToRegex;
    lens = [];
    for (len in lenToRegex) {
      lens.push(len);
      lenToRegex[len] = new RegExp(lenToRegex[len], 'g');
    }
    lens.sort(function(a, b){
      return b - a;
    });
    for (i$ = 0, len$ = lens.length; i$ < len$; ++i$) {
      len = lens[i$];
      results$.push(LTMRegexes.push(lenToRegex[len]));
    }
    return results$;
  }
  PUA2UNI = {
    '⿰𧾷百': '󾜅',
    '⿸疒哥': '󿗧',
    '⿰亻恩': '󿌇',
    '⿰虫念': '󿑂',
    '⿺皮卜': '󿕅'
  };
  grok = function(it){
    return JSON.parse((fs.readFileSync(it, 'utf8') + "").replace(/"bopomofo2": "[^"]*",/g, '').replace(/"heteronyms":/g, '"h":').replace(/"bopomofo":/g, '"b":').replace(/"pinyin":/g, '"p":').replace(/"definitions":/g, '"d":').replace(/"stroke_count":/g, '"c":').replace(/"non_radical_stroke_count":/g, '"n":').replace(/"def":/g, '"f":').replace(/"title":/g, '"t":').replace(/"radical":/g, '"r":').replace(/"example":/g, '"e":').replace(/"link":/g, '"l":').replace(/"synonyms":/g, '"s":').replace(/"antonyms":/g, '"a":').replace(/"quote":/g, '"q":').replace(/"trs":/g, '"T":').replace(/"alt":/g, '"A":').replace(/"vernacular":/g, '"V":').replace(/"combined":/g, '"C":').replace(/"dialects":/g, '"D":').replace(/"id":/g, '"_":').replace(/"audio_id":/g, '"=":').replace(/"specific_to":/g, '"S":').replace(/[⿰⿸⿺](?:𧾷|.)./g, function(it){
      return PUA2UNI[it] || process.exit(console.log(it));
    }));
  };
  entries = (function(){
    switch (lang) {
    case 'p':
      return grok('dict-amis.json');
    case 'm':
      return grok('dict-amis-mp.json');
    case 's':
      return grok('dict-amis-safolu.json');
    }
  }());
  i = 0;
  todo = 0;
  for (i$ = 0, len$ = entries.length; i$ < len$; ++i$) {
    entry = entries[i$], title = entry.t, heteronyms = entry.h;
    if (/\{\[[0-9a-f]{4}\]\}/.exec(title)) {
      continue;
    }
    if (/\uDB40[\uDD00-\uDD0F]/.exec(title)) {
      continue;
    }
    ++todo;
    pre = title.slice(0, 1);
    code = pre.charCodeAt(0);
    if (0xD800 <= code && code <= 0xDBFF) {
      pre = title.slice(0, 2);
      code = pre.charCodeAt(1) - 0xDC00;
    }
    entry.t = "";
    idx = code % (lang === 'a' ? 1024 : 128);
    englishIndex = title.indexOf('(');
    if (englishIndex >= 0) {
      entry.english = title.slice(englishIndex + 1, -1);
      title = title.slice(0, englishIndex);
    }
    if (audioMap) {
      for (j$ = 0, len1$ = heteronyms.length; j$ < len1$; ++j$) {
        i = j$;
        b = heteronyms[j$].b;
        if (!b) {
          break;
        }
        b = b.replace(/ /g, '\u3000').replace(/([ˇˊˋ])\u3000/g, '$1').replace(/ /g, '\u3000');
        b = replace$.call(b, /^（.*）/, '').replace(/（.*）.*/, '');
        audioTitle = replace$.call(title, /，/g, '');
        audioId = i
          ? audioMap[audioTitle + "." + b]
          : audioMap[audioTitle + "." + b] || (title.length > 1 ? audioMap[title] : void 8);
        if (audioId) {
          heteronyms[i]["="] = audioId;
        }
      }
    }
    chunk = JSON.stringify(entry).replace(/.[\u20E3\u20DE\u20DF\u20DD]/g, fn$);
    if (lang === 'p' || lang === 'm' || lang === 's') {
      x = procNoSeg(chunk, title, idx);
      console.log(x);
    } else {
      x = proc(chunk, title, idx);
      console.log(x);
    }
  }
  function fn$(it){
    return escape(it);
  }
}).call(this);
